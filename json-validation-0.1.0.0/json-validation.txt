-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package json-validation
@version 0.1.0.0


-- | JSON schema validation.
module Data.Aeson.Validation

-- | An opaque JSON <a>Schema</a>.
data Schema

-- | Does the <a>Value</a> satisfy the <a>Schema</a>?
schema :: Schema -> Value -> Bool

-- | Any <a>Bool</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema bool (Bool True)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema bool (Bool False)
--   True
--   </pre>
bool :: Schema

-- | <a>Bool</a> <a>True</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema true (Bool True)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema true (Bool False)
--   False
--   </pre>
true :: Schema

-- | <a>Bool</a> <a>False</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema false (Bool True)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema false (Bool False)
--   True
--   </pre>
false :: Schema

-- | Any <a>Number</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema number (Number 1.0)
--   True
--   </pre>
number :: Schema

-- | Any integer <a>Number</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema integer (Number 1.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema integer (Number 1.5)
--   False
--   </pre>
integer :: Schema

-- | Some <a>Number</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (someNumber (&gt; 5)) (Number 6)
--   True
--   </pre>
someNumber :: (Scientific -> Bool) -> Schema

-- | Some integer <a>Number</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (someInteger (&gt; 5)) (Number 6.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (someInteger (&gt; 5)) (Number 6.5)
--   False
--   </pre>
someInteger :: (Integer -> Bool) -> Schema

-- | Any <a>String</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema string (String "foo")
--   True
--   </pre>
string :: Schema

-- | An exact <a>String</a>. This is what the <tt>OverloadedStrings</tt>
--   instance uses when making a <a>Schema</a> from a string literal.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (theString "foo") (String "foo")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (theString "foo") (String "bar")
--   False
--   </pre>
theString :: Text -> Schema

-- | Some <a>String</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (someString (\s -&gt; Text.length s &gt; 5)) (String "foobar")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (someString (\s -&gt; Text.length s &gt; 5)) (String "foo")
--   False
--   </pre>
someString :: (Text -> Bool) -> Schema

-- | A <a>String</a> that matches a regular expression.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (regex "a+b") (String "xaaabx")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (regex "c{2}") (String "cd")
--   False
--   </pre>
regex :: Text -> Schema

-- | An opaque object <a>Field</a>.
--   
--   Create a <a>Field</a> with <a>.:</a> or <a>.:?</a>, and bundle it into
--   a <a>Schema</a> using <a>object</a> or <a>object'</a>
data Field

-- | An <a>Object</a>, possibly with additional unvalidated fields.
--   
--   To match any <a>Object</a>, use <tt><a>object</a> []</tt>.
object :: [Field] -> Schema

-- | An <a>Object</a> with no additional fields.
--   
--   The <tt>'</tt> mark means "strict" as in <tt>foldl'</tt>, because
--   <a>object'</a> matches <a>Object</a>s more strictly than
--   <a>object</a>.
object' :: [Field] -> Schema

-- | A required <a>Field</a>.
(.:) :: Text -> Schema -> Field
infixr 5 .:

-- | An optional <a>Field</a>.
(.:?) :: Text -> Schema -> Field
infixr 5 .:?

-- | A "homogenous" <a>Array</a> of any size.
--   
--   The array need not be <i>truly</i> homogenous; it simply has the same
--   <a>Schema</a> applied to each element. However, the <a>Schema</a>
--   could be <a>anything</a>, or composed of many alternatives using
--   <a>&lt;&gt;</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (array bool) (Array [Bool True, Bool False])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (array anything) (Array [Bool True, String "foo"])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (array integer) (Array [Number 1.5])
--   False
--   </pre>
array :: Schema -> Schema

-- | A sized (inclusive), "homogenous" (see note above) <a>Array</a>. Use
--   <a>minBound</a> or <a>maxBound</a> for an unbounded edge.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (sizedArray 1 2 bool) (Array [Bool True])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (sizedArray 1 2 bool) (Array [Bool True, Bool True, Bool False])
--   False
--   </pre>
sizedArray :: Int -> Int -> Schema -> Schema

-- | A "homogenous" (see note above), unique <a>Array</a> of any size.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (set bool) (Array [Bool True])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (set bool) (Array [Bool True, Bool True])
--   False
--   </pre>
set :: Schema -> Schema

-- | A sized (inclusive), "homogenous" (see note above), unique
--   <a>Array</a>. Use <a>minBound</a> or <a>maxBound</a> for an unbounded
--   edge.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (sizedSet 1 1 string) (Array [String "foo"])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (sizedSet 1 1 string) (Array [String "foo", String "bar"])
--   False
--   </pre>
sizedSet :: Int -> Int -> Schema -> Schema

-- | A heterogeneous <a>Array</a> exactly as long as the given list of
--   <a>Schema</a>s.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (tuple [bool, string]) (Array [Bool True, String "foo"])
--   True
--   </pre>
tuple :: [Schema] -> Schema

-- | Any <a>Value</a> whatsoever, including <a>Null</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema anything Null
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema anything (Bool True)
--   True
--   </pre>
anything :: Schema

-- | Modify a <a>Schema</a> to additionally accept <a>Null</a>.
--   
--   <a>nullable</a> is idempotent:
--   
--   <pre>
--   <a>nullable</a> = <a>nullable</a> . <a>nullable</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (nullable bool) (Bool True)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (nullable bool) Null
--   True
--   </pre>
nullable :: Schema -> Schema
instance Data.Semigroup.Semigroup Data.Aeson.Validation.Schema
instance GHC.Num.Num Data.Aeson.Validation.Schema
instance Data.String.IsString Data.Aeson.Validation.Schema
