-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lightweight combinators for validating JSON
--   
--   JSON schema validation
@package json-validation
@version 0.1.0.0


-- | JSON schema validation.
module Data.Aeson.Validation

-- | An opaque JSON <a>Schema</a>.
data Schema

-- | Does the <a>Value</a> satisfy the <a>Schema</a>?
--   
--   <pre>
--   <a>schema</a> s v = <a>null</a> (<a>validate</a> s v)
--   </pre>
schema :: Schema -> Value -> Bool

-- | Validate a <a>Value</a> with a <a>Schema</a> and emit schema
--   violations as <a>Text</a>.
validate :: Schema -> Value -> [Text]

-- | Any <a>Bool</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema bool (Bool True)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema bool (Bool False)
--   True
--   </pre>
bool :: Schema

-- | <a>Bool</a> <a>True</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema true (Bool True)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema true (Bool False)
--   False
--   </pre>
true :: Schema

-- | <a>Bool</a> <a>False</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema false (Bool True)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema false (Bool False)
--   True
--   </pre>
false :: Schema

-- | Any <a>Number</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema number (Number 1.0)
--   True
--   </pre>
number :: Schema

-- | An <i>approximate</i> <a>Number</a>, with a relative tolerance of
--   <tt>1^-9</tt> (the smaller number must be within <tt>0.0000001%</tt>
--   of the larger number).
--   
--   You may use a floating point literal instead.
--   
--   Here is how you'd implement <a>theNumber</a> using <a>someNumber</a>,
--   in case you want to use a different tolerance:
--   
--   <pre>
--   <a>theNumber</a> :: <a>Scientific</a> -&gt; <a>Schema</a>
--   <a>theNumber</a> n = <a>someNumber</a> (isClose n)
--     where
--       isClose :: <a>Scientific</a> -&gt; <a>Scientific</a> -&gt; <a>Bool</a>
--       isClose a b = <a>abs</a> (a-b) <a>&lt;=</a> 1e-9 * <a>max</a> (<a>abs</a> a) (<a>abs</a> b)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (theNumber 1.5) (Number 1.5)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema 2.5 (Number 2.500000001)
--   True
--   </pre>
theNumber :: Scientific -> Schema

-- | Some <a>Number</a>.
--   
--   The unexported <tt>A</tt> typeclass exists to overload
--   <a>someNumber</a> with precicely two possible types:
--   
--   <pre>
--   <a>someNumber</a> :: (<a>Scientific</a> -&gt; <a>Bool</a>) -&gt; <a>Schema</a>
--   <a>someNumber</a> :: (<a>Scientific</a> -&gt; <a>Bool</a>) -&gt; <a>Text</a> -&gt; <a>Schema</a>
--   </pre>
--   
--   The optional <a>Text</a> argument is used for error reporting if
--   validation fails.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (someNumber (&gt; 5)) (Number 6)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; validate (someNumber (&gt; 5) "greater than 5") (Number 4)
--   ["failed predicate: greater than 5"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; validate (someNumber (&gt; 5)) (Number 4)
--   ["failed predicate"]
--   </pre>
someNumber :: A schema => (Scientific -> Bool) -> schema

-- | Any integer <a>Number</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema integer (Number 1.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema integer (Number 1.5)
--   False
--   </pre>
integer :: Schema

-- | An exact integer <a>Number</a>.
--   
--   You may use an integer literal instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (theInteger 1) (Number 1)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema 1 (Number 2)
--   False
--   </pre>
theInteger :: Integer -> Schema

-- | Some integer <a>Number</a>.
--   
--   The unexported <tt>A</tt> typeclass exists to overload
--   <a>someInteger</a> with precicely two possible types:
--   
--   <pre>
--   <a>someInteger</a> :: (<a>Integer</a> -&gt; <a>Bool</a>) -&gt; <a>Schema</a>
--   <a>someInteger</a> :: (<a>Integer</a> -&gt; <a>Bool</a>) -&gt; <a>Text</a> -&gt; <a>Schema</a>
--   </pre>
--   
--   The optional <a>Text</a> argument is used for error reporting if
--   validation fails.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (someInteger (&gt; 5)) (Number 6.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; validate (someInteger (&gt; 5) "greater than 5") (Number 6.5)
--   ["failed predicate: greater than 5"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; validate (someInteger (&gt; 5)) (Number 6.5)
--   ["failed predicate"]
--   </pre>
someInteger :: A schema => (Integer -> Bool) -> schema

-- | Any <a>String</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema string (String "foo")
--   True
--   </pre>
string :: Schema

-- | An exact <a>String</a>.
--   
--   You may use a string literal instead (requires
--   <tt>-XOverloadedStrings</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (theString "foo") (String "foo")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema "foo" (String "bar")
--   False
--   </pre>
theString :: Text -> Schema

-- | Some <a>String</a>.
--   
--   The unexported <tt>A</tt> typeclass exists to overload
--   <a>someString</a> with precicely two possible types:
--   
--   <pre>
--   <a>someString</a> :: (<a>Text</a> -&gt; <a>Bool</a>) -&gt; <a>Schema</a>
--   <a>someString</a> :: (<a>Text</a> -&gt; <a>Bool</a>) -&gt; <a>Text</a> -&gt; <a>Schema</a>
--   </pre>
--   
--   The optional <a>Text</a> argument is used for error reporting if
--   validation fails.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (someString (\s -&gt; Text.length s &gt; 5)) (String "foobar")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (someString (\s -&gt; Text.length s &gt; 5)) (String "foo")
--   False
--   </pre>
someString :: A schema => (Text -> Bool) -> schema

-- | A <a>String</a> that matches a regular expression.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (regex "a+b") (String "xaaabx")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (regex "c{2}") (String "cd")
--   False
--   </pre>
regex :: Text -> Schema

-- | A <a>String</a> in <a>ISO 8601</a> format.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema datetime (String "2000-01-01T00:00:00.000Z")
--   True
--   </pre>
datetime :: Schema

-- | An opaque object <a>Field</a>.
--   
--   Create a <a>Field</a> with <tt>.:</tt> or <tt>.:?</tt>, and bundle it
--   into a <a>Schema</a> using <tt>object</tt> or <tt>object'</tt>
data Field

-- | An arbitrarily deep non-empty <a>Path</a> into an <tt>Object</tt>,
--   created with either string-literal or list-literal syntax.
--   
--   Beware: the <a>IsList</a> instance is partial; <tt>[]</tt> is not
--   allowed and will call <a>error</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "foo" :: Path
--   ["foo"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ["foo", "bar"] :: Path
--   ["foo","bar"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] :: Path
--   *** Exception: Data.Aeson.Validation.Path.fromList: empty list
--   </pre>
data Path

-- | An <a>Object</a>, possibly with additional fields.
--   
--   To match any <a>Object</a>, use <tt><a>object</a> []</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let fields = ["foo" .: number]
--   
--   &gt;&gt;&gt; let values = ["foo" .= Number 1, "bar" .= Bool True]
--   
--   &gt;&gt;&gt; schema (object fields) (Object values)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fields = [["foo", "bar"] .: number]
--   
--   &gt;&gt;&gt; let values = ["foo" .= Object ["bar" .= Number 1]]
--   
--   &gt;&gt;&gt; schema (object fields) (Object values)
--   True
--   </pre>
object :: [Field] -> Schema

-- | An <a>Object</a> with no additional fields.
--   
--   The <tt>'</tt> mark means "strict" as in <tt>foldl'</tt>, because
--   <a>object'</a> matches <a>Object</a>s more strictly than
--   <a>object</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let fields = ["foo" .: number]
--   
--   &gt;&gt;&gt; let values = ["foo" .= Number 1]
--   
--   &gt;&gt;&gt; schema (object' fields) (Object values)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fields = ["foo" .: number]
--   
--   &gt;&gt;&gt; let values = ["foo" .= Number 1, "bar" .= Bool True]
--   
--   &gt;&gt;&gt; schema (object' fields) (Object values)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fields = [["foo", "bar"] .: number]
--   
--   &gt;&gt;&gt; let values = ["foo" .= Object ["bar" .= Number 1]]
--   
--   &gt;&gt;&gt; schema (object' fields) (Object values)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fields = [["foo", "bar"] .: number]
--   
--   &gt;&gt;&gt; let values = ["foo" .= Object ["bar" .= Number 1], "baz" .= Bool True]
--   
--   &gt;&gt;&gt; schema (object' fields) (Object values)
--   False
--   </pre>
object' :: [Field] -> Schema

-- | A required <a>Field</a>.
(.:) :: Path -> Schema -> Field
infixr 5 .:

-- | An optional <a>Field</a>.
(.:?) :: Path -> Schema -> Field
infixr 5 .:?

-- | A "homogenous" <a>Array</a> of any size.
--   
--   The array need not be <i>truly</i> homogenous; it simply has the same
--   <a>Schema</a> applied to each element. However, the <a>Schema</a>
--   could be <a>anything</a>, or composed of many alternatives using
--   <a>&lt;&gt;</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (array bool) (Array [Bool True, Bool False])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (array anything) (Array [Bool True, String "foo"])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (array integer) (Array [Number 1.5])
--   False
--   </pre>
array :: Schema -> Schema

-- | A sized (inclusive), "homogenous" (see note above) <a>Array</a>. Use
--   <a>minBound</a> or <a>maxBound</a> for an unbounded edge.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (sizedArray 1 2 bool) (Array [Bool True])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (sizedArray 1 2 bool) (Array [Bool True, Bool True, Bool False])
--   False
--   </pre>
sizedArray :: Int -> Int -> Schema -> Schema

-- | A "homogenous" (see note above), unique <a>Array</a> of any size.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (set bool) (Array [Bool True])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (set bool) (Array [Bool True, Bool True])
--   False
--   </pre>
set :: Schema -> Schema

-- | A sized (inclusive), "homogenous" (see note above), unique
--   <a>Array</a>. Use <a>minBound</a> or <a>maxBound</a> for an unbounded
--   edge.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (sizedSet 1 1 string) (Array [String "foo"])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (sizedSet 1 1 string) (Array [String "foo", String "bar"])
--   False
--   </pre>
sizedSet :: Int -> Int -> Schema -> Schema

-- | A heterogeneous <a>Array</a> exactly as long as the given list of
--   <a>Schema</a>s.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (tuple [bool, string]) (Array [Bool True, String "foo"])
--   True
--   </pre>
tuple :: [Schema] -> Schema

-- | Any <a>Value</a> whatsoever, including <a>Null</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema anything (Bool True)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema anything Null
--   True
--   </pre>
anything :: Schema

-- | Modify a <a>Schema</a> to additionally accept <a>Null</a>.
--   
--   <a>nullable</a> is idempotent:
--   
--   <pre>
--   <a>nullable</a> = <a>nullable</a> . <a>nullable</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; schema (nullable bool) (Bool True)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schema (nullable bool) Null
--   True
--   </pre>
nullable :: Schema -> Schema
instance GHC.Generics.Generic (Data.Aeson.Validation.Pair a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Aeson.Validation.Pair a b)
instance GHC.Base.Monoid Data.Aeson.Validation.FieldMap
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (Data.Aeson.Validation.Pair a b)
instance Data.Aeson.Validation.A Data.Aeson.Validation.Internal.Schema
instance a ~ Data.Text.Internal.Text => Data.Aeson.Validation.A (a -> Data.Aeson.Validation.Internal.Schema)
