-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast JSON parsing and encoding
--   
--   A JSON parsing and encoding library optimized for ease of use and high
--   performance.
--   
--   To get started, see the documentation for the <tt>Data.Aeson</tt>
--   module below.
--   
--   Parsing performance on a late 2013 MacBook Pro (2.6GHz Core i7),
--   running 64-bit GHC 7.10.1, for mostly-English tweets from Twitter's
--   JSON search API:
--   
--   <ul>
--   <li>6.4 KB payloads, English: 7570 msg/sec (47.6 MB/sec)</li>
--   <li>14.6 KB payloads, Japanese: 3261 msg/sec (46.6 MB/sec)</li>
--   </ul>
--   
--   Encoding performance on the same machine and data:
--   
--   <ul>
--   <li>6.4 KB payloads, English: 22738 msg/sec (142.9 MB/sec)</li>
--   <li>14.6 KB payloads, Japanese: 15911 msg/sec (227.4 MB/sec)</li>
--   </ul>
--   
--   (A note on naming: in Greek mythology, Aeson was the father of Jason.)
@package aeson
@version 0.11.2.1


-- | Efficiently and correctly parse a JSON string. The string must be
--   encoded as UTF-8.
--   
--   It can be useful to think of parsing as occurring in two phases:
--   
--   <ul>
--   <li>Identification of the textual boundaries of a JSON value. This is
--   always strict, so that an invalid JSON document can be rejected as
--   soon as possible.</li>
--   <li>Conversion of a JSON value to a Haskell value. This may be either
--   immediate (strict) or deferred (lazy); see below for details.</li>
--   </ul>
--   
--   The question of whether to choose a lazy or strict parser is subtle,
--   but it can have significant performance implications, resulting in
--   changes in CPU use and memory footprint of 30% to 50%, or occasionally
--   more. Measure the performance of your application with each!
module Data.Aeson.Parser

-- | Parse a top-level JSON value.
--   
--   The conversion of a parsed value to a Haskell value is deferred until
--   the Haskell value is needed. This may improve performance if only a
--   subset of the results of conversions are needed, but at a cost in
--   thunk allocation.
--   
--   This function is an alias for <a>value</a>. In aeson 0.8 and earlier,
--   it parsed only object or array types, in conformance with the
--   now-obsolete RFC 4627.
json :: Parser Value

-- | Parse any JSON value. You should usually <a>json</a> in preference to
--   this function, as this function relaxes the object-or-array
--   requirement of RFC 4627.
--   
--   In particular, be careful in using this function if you think your
--   code might interoperate with Javascript. A na√Øve Javascript library
--   that parses JSON data using <tt>eval</tt> is vulnerable to attack
--   unless the encoded data represents an object or an array. JSON
--   implementations in other languages conform to that same restriction to
--   preserve interoperability and security.
value :: Parser Value

-- | Parse a quoted JSON string.
jstring :: Parser Text

-- | Parse a top-level JSON value.
--   
--   This is a strict version of <a>json</a> which avoids building up
--   thunks during parsing; it performs all conversions immediately. Prefer
--   this version if most of the JSON data needs to be accessed.
--   
--   This function is an alias for <a>value'</a>. In aeson 0.8 and earlier,
--   it parsed only object or array types, in conformance with the
--   now-obsolete RFC 4627.
json' :: Parser Value

-- | Strict version of <a>value</a>. See also <a>json'</a>.
value' :: Parser Value


module Data.Aeson.Internal.Time

-- | Like TimeOfDay, but using a fixed-width integer for seconds.
data TimeOfDay64
TOD :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int64 -> TimeOfDay64
fromPico :: Pico -> Integer
toPico :: Integer -> Pico
diffTimeOfDay64 :: DiffTime -> TimeOfDay64
toTimeOfDay64 :: TimeOfDay -> TimeOfDay64


-- | Types for working with JSON data.
module Data.Aeson.Types

-- | A JSON value represented as a Haskell value.
data Value
Object :: !Object -> Value
Array :: !Array -> Value
String :: !Text -> Value
Number :: !Scientific -> Value
Bool :: !Bool -> Value
Null :: Value

-- | An encoding of a JSON value.
data Encoding

-- | Make Encoding from Builder.
--   
--   Use with care! You have to make sure that the passed Builder is a
--   valid JSON Encoding!
unsafeToEncoding :: Builder -> Encoding

-- | Acquire the underlying bytestring builder.
fromEncoding :: Encoding -> Builder

-- | A series of values that, when encoded, should be separated by commas.
--   Since 0.11.0.0, the <tt>.=</tt> operator is overloaded to create
--   either <tt>(Text, Value)</tt> or <a>Series</a>. You can use Series
--   when encoding directly to a bytestring builder as in the following
--   example:
--   
--   <pre>
--   toEncoding (Person name age) = pairs ("name" .= name &lt;&gt; "age" .= age)
--   </pre>
data Series

-- | A JSON "array" (sequence).
type Array = Vector Value

-- | The empty array.
emptyArray :: Value

-- | A key/value pair for an <a>Object</a>.
type Pair = (Text, Value)

-- | A JSON "object" (key/value map).
type Object = HashMap Text Value

-- | The empty object.
emptyObject :: Value

-- | A newtype wrapper for <a>UTCTime</a> that uses the same non-standard
--   serialization format as Microsoft .NET, whose <a>System.DateTime</a>
--   type is by default serialized to JSON as in the following example:
--   
--   <pre>
--   /Date(1302547608878)/
--   </pre>
--   
--   The number represents milliseconds since the Unix epoch.
newtype DotNetTime
DotNetTime :: UTCTime -> DotNetTime

-- | Acquire the underlying value.
[fromDotNetTime] :: DotNetTime -> UTCTime

-- | Fail parsing due to a type mismatch, with a descriptive message.
--   
--   Example usage:
--   
--   <pre>
--   instance FromJSON Coord where
--     parseJSON (<a>Object</a> v) = {- type matches, life is good -}
--     parseJSON wat        = <a>typeMismatch</a> "Coord" wat
--   </pre>
typeMismatch :: String -> Value -> Parser a

-- | A JSON parser.
data Parser a

-- | The result of running a <a>Parser</a>.
data Result a
Error :: String -> Result a
Success :: a -> Result a

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   In many cases, you can get the compiler to generate parsing code for
--   you (see below). To begin, let's cover writing an instance by hand.
--   
--   There are various reasons a conversion could fail. For example, an
--   <a>Object</a> could be missing a required key, an <a>Array</a> could
--   be of the wrong size, or a value could be of an incompatible type.
--   
--   The basic ways to signal a failed conversion are as follows:
--   
--   <ul>
--   <li><tt>empty</tt> and <tt>mzero</tt> work, but are terse and
--   uninformative</li>
--   <li><a>fail</a> yields a custom error message</li>
--   <li><a>typeMismatch</a> produces an informative message for cases when
--   the value encountered is not of the expected type</li>
--   </ul>
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--     parseJSON (<a>Object</a> v) = Coord    <a>&lt;$&gt;</a>
--                            v <tt>.:</tt> "x" <a>&lt;*&gt;</a>
--                            v <tt>.:</tt> "y"
--   
--     -- We do not expect a non-<a>Object</a> value here.
--     -- We could use <tt>mzero</tt> to fail, but <a>typeMismatch</a>
--     -- gives a much more informative error message.
--     parseJSON invalid    = <a>typeMismatch</a> "Coord" invalid
--   </pre>
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   two options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>parseJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>FromJSON</a> instance for
--   your datatype without giving a definition for <a>parseJSON</a>.
--   
--   For example, the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance FromJSON Coord
--   </pre>
--   
--   If <tt>DefaultSignatures</tt> doesn't give exactly the results you
--   want, you can customize the generic decoding with only a tiny amount
--   of effort, using <a>genericParseJSON</a> with your preferred
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a where parseJSON = genericParseJSON defaultOptions
parseJSON :: FromJSON a => Value -> Parser a
parseJSON :: (FromJSON a, Generic a, GFromJSON (Rep a)) => Value -> Parser a

-- | Convert a value from JSON, failing if the types do not match.
fromJSON :: (FromJSON a) => Value -> Result a

-- | Run a <a>Parser</a>.
parse :: (a -> Parser b) -> a -> Result b

-- | Run a <a>Parser</a> with an <a>Either</a> result type. If the parse
--   fails, the <a>Left</a> payload will contain an error message.
parseEither :: (a -> Parser b) -> a -> Either String b

-- | Run a <a>Parser</a> with a <a>Maybe</a> result type.
parseMaybe :: (a -> Parser b) -> a -> Maybe b

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where
--     toJSON (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   
--     toEncoding (Coord x y) = <tt>pairs</tt> ("x" <a>.=</a> x <tt>&lt;&gt;</tt> "y" <a>.=</a> y)
--   </pre>
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are two
--   options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>toJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>ToJSON</a> instance for your
--   datatype without giving definitions for <a>toJSON</a> or
--   <a>toEncoding</a>.
--   
--   For example, the previous example can be simplified to a more minimal
--   instance:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance ToJSON Coord where
--       toEncoding = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
--   
--   Why do we provide an implementation for <a>toEncoding</a> here? The
--   <a>toEncoding</a> function is a relatively new addition to this class.
--   To allow users of older versions of this library to upgrade without
--   having to edit all of their instances or encounter surprising
--   incompatibilities, the default implementation of <a>toEncoding</a>
--   uses <a>toJSON</a>. This produces correct results, but since it
--   performs an intermediate conversion to a <a>Value</a>, it will be less
--   efficient than directly emitting an <a>Encoding</a>. Our one-liner
--   definition of <a>toEncoding</a> above bypasses the intermediate
--   <a>Value</a>.
--   
--   If <tt>DefaultSignatures</tt> doesn't give exactly the results you
--   want, you can customize the generic encoding with only a tiny amount
--   of effort, using <a>genericToJSON</a> and <a>genericToEncoding</a>
--   with your preferred <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON     = <a>genericToJSON</a> <a>defaultOptions</a>
--       toEncoding = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a where toJSON = genericToJSON defaultOptions toEncoding = Encoding . encodeToBuilder . toJSON

-- | Convert a Haskell value to a JSON-friendly intermediate type.
toJSON :: ToJSON a => a -> Value

-- | Convert a Haskell value to a JSON-friendly intermediate type.
toJSON :: (ToJSON a, Generic a, GToJSON (Rep a)) => a -> Value

-- | Encode a Haskell value as JSON.
--   
--   The default implementation of this method creates an intermediate
--   <a>Value</a> using <a>toJSON</a>. This provides source-level
--   compatibility for people upgrading from older versions of this
--   library, but obviously offers no performance advantage.
--   
--   To benefit from direct encoding, you <i>must</i> provide an
--   implementation for this method. The easiest way to do so is by having
--   your types implement <a>Generic</a> using the <tt>DeriveGeneric</tt>
--   extension, and then have GHC generate a method body as follows.
--   
--   <pre>
--   instance ToJSON Coord where
--       toEncoding = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
toEncoding :: ToJSON a => a -> Encoding

-- | A key-value pair for encoding a JSON object.
class KeyValue kv
(.=) :: (KeyValue kv, ToJSON v) => Text -> v -> kv

-- | If the inner <tt>Parser</tt> failed, modify the failure message using
--   the provided function. This allows you to create more descriptive
--   error messages. For example:
--   
--   <pre>
--   parseJSON (Object o) = modifyFailure
--       ("Parsing of the Foo value failed: " ++)
--       (Foo &lt;$&gt; o .: "someField")
--   </pre>
--   
--   Since 0.6.2.0
modifyFailure :: (String -> String) -> Parser a -> Parser a

-- | Class of generic representation types (<a>Rep</a>) that can be
--   converted from JSON.
class GFromJSON f

-- | This method (applied to <a>defaultOptions</a>) is used as the default
--   generic implementation of <a>parseJSON</a>.
gParseJSON :: GFromJSON f => Options -> Value -> Parser (f a)

-- | Class of generic representation types (<a>Rep</a>) that can be
--   converted to JSON.
class GToJSON f

-- | This method (applied to <a>defaultOptions</a>) is used as the default
--   generic implementation of <a>toJSON</a>.
gToJSON :: GToJSON f => Options -> f a -> Value

-- | Class of generic representation types (<a>Rep</a>) that can be
--   converted to a JSON <a>Encoding</a>.
class GToEncoding f

-- | This method (applied to <a>defaultOptions</a>) can be used as the
--   default generic implementation of <a>toEncoding</a>.
gToEncoding :: GToEncoding f => Options -> f a -> Encoding

-- | A configurable generic JSON creator. This function applied to
--   <a>defaultOptions</a> is used as the default for <a>toJSON</a> when
--   the type is an instance of <a>Generic</a>.
genericToJSON :: (Generic a, GToJSON (Rep a)) => Options -> a -> Value

-- | A configurable generic JSON encoder. This function applied to
--   <a>defaultOptions</a> is used as the default for <a>toEncoding</a>
--   when the type is an instance of <a>Generic</a>.
genericToEncoding :: (Generic a, GToEncoding (Rep a)) => Options -> a -> Encoding

-- | A configurable generic JSON decoder. This function applied to
--   <a>defaultOptions</a> is used as the default for <a>parseJSON</a> when
--   the type is an instance of <a>Generic</a>.
genericParseJSON :: (Generic a, GFromJSON (Rep a)) => Options -> Value -> Parser a

-- | <tt>withObject expected f value</tt> applies <tt>f</tt> to the
--   <a>Object</a> when <tt>value</tt> is an <tt>Object</tt> and fails
--   using <tt><a>typeMismatch</a> expected</tt> otherwise.
withObject :: String -> (Object -> Parser a) -> Value -> Parser a

-- | <tt>withText expected f value</tt> applies <tt>f</tt> to the
--   <a>Text</a> when <tt>value</tt> is a <tt>String</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withText :: String -> (Text -> Parser a) -> Value -> Parser a

-- | <tt>withArray expected f value</tt> applies <tt>f</tt> to the
--   <a>Array</a> when <tt>value</tt> is an <tt>Array</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withArray :: String -> (Array -> Parser a) -> Value -> Parser a

-- | <tt>withNumber expected f value</tt> applies <tt>f</tt> to the
--   <a>Number</a> when <tt>value</tt> is a <a>Number</a>. and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.

-- | <i>Deprecated: Use withScientific instead</i>
withNumber :: String -> (Number -> Parser a) -> Value -> Parser a

-- | <tt>withScientific expected f value</tt> applies <tt>f</tt> to the
--   <a>Scientific</a> number when <tt>value</tt> is a <a>Number</a>. and
--   fails using <tt><a>typeMismatch</a> expected</tt> otherwise.
withScientific :: String -> (Scientific -> Parser a) -> Value -> Parser a

-- | <tt>withBool expected f value</tt> applies <tt>f</tt> to the
--   <a>Bool</a> when <tt>value</tt> is a <tt>Bool</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withBool :: String -> (Bool -> Parser a) -> Value -> Parser a

-- | Encode a series of key/value pairs, separated by commas.
pairs :: Series -> Encoding

-- | Encode a <a>Foldable</a> as a JSON array.
foldable :: (Foldable t, ToJSON a) => t a -> Encoding

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <tt>empty</tt> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use <a>.:?</a> instead.
(.:) :: (FromJSON a) => Object -> Text -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present, or
--   <tt>empty</tt> if the value cannot be converted to the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use <a>.:</a> instead.
(.:?) :: (FromJSON a) => Object -> Text -> Parser (Maybe a)

-- | Like <a>.:?</a>, but the resulting parser will fail, if the key is
--   present but is <a>Null</a>.
(.:!) :: (FromJSON a) => Object -> Text -> Parser (Maybe a)

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use
--   <a>.:</a> instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value

-- | Options that specify how to encode/decode your datatype to/from JSON.
data Options
Options :: (String -> String) -> (String -> String) -> Bool -> Bool -> SumEncoding -> Bool -> Options

-- | Function applied to field labels. Handy for removing common record
--   prefixes for example.
[fieldLabelModifier] :: Options -> String -> String

-- | Function applied to constructor tags which could be handy for
--   lower-casing them for example.
[constructorTagModifier] :: Options -> String -> String

-- | If <a>True</a> the constructors of a datatype, with <i>all</i> nullary
--   constructors, will be encoded to just a string with the constructor
--   tag. If <a>False</a> the encoding will always follow the
--   <a>sumEncoding</a>.
[allNullaryToStringTag] :: Options -> Bool

-- | If <a>True</a> record fields with a <a>Nothing</a> value will be
--   omitted from the resulting object. If <a>False</a> the resulting
--   object will include those fields mapping to <tt>null</tt>.
[omitNothingFields] :: Options -> Bool

-- | Specifies how to encode constructors of a sum datatype.
[sumEncoding] :: Options -> SumEncoding

-- | Hide the field name when a record constructor has only one field, like
--   a newtype.
[unwrapUnaryRecords] :: Options -> Bool

-- | Specifies how to encode constructors of a sum datatype.
data SumEncoding

-- | A constructor will be encoded to an object with a field
--   <a>tagFieldName</a> which specifies the constructor tag (modified by
--   the <a>constructorTagModifier</a>). If the constructor is a record the
--   encoded record fields will be unpacked into this object. So make sure
--   that your record doesn't have a field with the same label as the
--   <a>tagFieldName</a>. Otherwise the tag gets overwritten by the encoded
--   value of that field! If the constructor is not a record the encoded
--   constructor contents will be stored under the <a>contentsFieldName</a>
--   field.
TaggedObject :: String -> String -> SumEncoding
[tagFieldName] :: SumEncoding -> String
[contentsFieldName] :: SumEncoding -> String

-- | A constructor will be encoded to an object with a single field named
--   after the constructor tag (modified by the
--   <a>constructorTagModifier</a>) which maps to the encoded contents of
--   the constructor.
ObjectWithSingleField :: SumEncoding

-- | A constructor will be encoded to a 2-element array where the first
--   element is the tag of the constructor (modified by the
--   <a>constructorTagModifier</a>) and the second element the encoded
--   contents of the constructor.
TwoElemArray :: SumEncoding

-- | Converts from CamelCase to another lower case, interspersing the
--   character between all capital letters and their previous entries,
--   except those capital letters that appear together, like <tt>API</tt>.
--   
--   For use by Aeson template haskell calls.
--   
--   <pre>
--   camelTo '_' 'CamelCaseAPI' == "camel_case_api"
--   </pre>

-- | <i>Deprecated: Use camelTo2 for better results</i>
camelTo :: Char -> String -> String

-- | Better version of <a>camelTo</a>. Example where it works better:
--   
--   <pre>
--   camelTo '_' 'CamelAPICase' == "camel_apicase"
--   camelTo2 '_' 'CamelAPICase' == "camel_api_case"
--   </pre>
camelTo2 :: Char -> String -> String

-- | Default encoding <a>Options</a>:
--   
--   <pre>
--   <a>Options</a>
--   { <a>fieldLabelModifier</a>      = id
--   , <a>constructorTagModifier</a>  = id
--   , <a>allNullaryToStringTag</a>   = True
--   , <a>omitNothingFields</a>       = False
--   , <a>sumEncoding</a>             = <a>defaultTaggedObject</a>
--   , <a>unwrapUnaryRecords</a>      = False
--   }
--   </pre>
defaultOptions :: Options

-- | Default <a>TaggedObject</a> <a>SumEncoding</a> options:
--   
--   <pre>
--   defaultTaggedObject = <a>TaggedObject</a>
--                         { <a>tagFieldName</a>      = "tag"
--                         , <a>contentsFieldName</a> = "contents"
--                         }
--   </pre>
defaultTaggedObject :: SumEncoding


-- | Internal types and functions.
--   
--   <b>Note</b>: all declarations in this module are unstable, and prone
--   to being changed at any time.
module Data.Aeson.Internal

-- | The internal result of running a <a>Parser</a>.
data IResult a
IError :: JSONPath -> String -> IResult a
ISuccess :: a -> IResult a

-- | Elements of a JSON path used to describe the location of an error.
data JSONPathElement

-- | JSON path element of a key into an object, "object.key".
Key :: Text -> JSONPathElement

-- | JSON path element of an index into an array, "array[index]".
Index :: {-# UNPACK #-} !Int -> JSONPathElement
type JSONPath = [JSONPathElement]

-- | Add JSON Path context to a parser
--   
--   When parsing a complex structure, it helps to annotate (sub)parsers
--   with context, so that if an error occurs, you can find its location.
--   
--   <pre>
--   withObject "Person" $ \o -&gt;
--     Person
--       &lt;$&gt; o .: "name" &lt;?&gt; Key "name"
--       &lt;*&gt; o .: "age"  &lt;?&gt; Key "age"
--   </pre>
--   
--   (Standard methods like '(.:)' already do this.)
--   
--   With such annotations, if an error occurs, you will get a JSON Path
--   location of that error.
--   
--   Since 0.10
(<?>) :: Parser a -> JSONPathElement -> Parser a

-- | Annotate an error message with a <a>JSONPath</a> error location.
formatError :: JSONPath -> String -> String

-- | Convert a value from JSON, failing if the types do not match.
ifromJSON :: (FromJSON a) => Value -> IResult a

-- | Run a <a>Parser</a>.
iparse :: (a -> Parser b) -> a -> IResult b


-- | Efficiently serialize a JSON value.
--   
--   Most frequently, you'll probably want to encode straight to UTF-8 (the
--   standard JSON encoding) using <a>encode</a>.
--   
--   You can use the conversions to <a>Builder</a>s when embedding JSON
--   messages as parts of a protocol.
module Data.Aeson.Encode

-- | Efficiently serialize a JSON value as a lazy <a>ByteString</a>.
--   
--   This is implemented in terms of the <a>ToJSON</a> class's
--   <a>toEncoding</a> method.
encode :: ToJSON a => a -> ByteString

-- | Encode a JSON value to a <a>Data.ByteString</a> <a>Builder</a>.
--   
--   Use this function if you are encoding over the wire, or need to
--   prepend or append further bytes to the encoded JSON value.
encodeToBuilder :: Value -> Builder

-- | Encode a JSON <a>Value</a> to a <a>Data.Text</a> <a>Builder</a>, which
--   can be embedded efficiently in a text-based protocol.
--   
--   If you are going to immediately encode straight to a
--   <a>ByteString</a>, it is more efficient to use <a>encodeToBuilder</a>
--   instead.
encodeToTextBuilder :: Value -> Builder

-- | <i>Deprecated: Use <a>encodeToTextBuilder</a> instead</i>
fromValue :: Value -> Builder


-- | Types and functions for working efficiently with JSON data.
--   
--   (A note on naming: in Greek mythology, Aeson was the father of Jason.)
module Data.Aeson

-- | Efficiently deserialize a JSON value from a lazy <a>ByteString</a>. If
--   this fails due to incomplete or invalid input, <a>Nothing</a> is
--   returned.
--   
--   The input must consist solely of a JSON document, with no trailing
--   data except for whitespace.
--   
--   This function parses immediately, but defers conversion. See
--   <a>json</a> for details.
decode :: (FromJSON a) => ByteString -> Maybe a

-- | Efficiently deserialize a JSON value from a lazy <a>ByteString</a>. If
--   this fails due to incomplete or invalid input, <a>Nothing</a> is
--   returned.
--   
--   The input must consist solely of a JSON document, with no trailing
--   data except for whitespace.
--   
--   This function parses and performs conversion immediately. See
--   <a>json'</a> for details.
decode' :: (FromJSON a) => ByteString -> Maybe a

-- | Like <a>decode</a> but returns an error message when decoding fails.
eitherDecode :: (FromJSON a) => ByteString -> Either String a

-- | Like <a>decode'</a> but returns an error message when decoding fails.
eitherDecode' :: (FromJSON a) => ByteString -> Either String a

-- | Efficiently serialize a JSON value as a lazy <a>ByteString</a>.
--   
--   This is implemented in terms of the <a>ToJSON</a> class's
--   <a>toEncoding</a> method.
encode :: ToJSON a => a -> ByteString

-- | Efficiently deserialize a JSON value from a strict <a>ByteString</a>.
--   If this fails due to incomplete or invalid input, <a>Nothing</a> is
--   returned.
--   
--   The input must consist solely of a JSON document, with no trailing
--   data except for whitespace.
--   
--   This function parses immediately, but defers conversion. See
--   <a>json</a> for details.
decodeStrict :: (FromJSON a) => ByteString -> Maybe a

-- | Efficiently deserialize a JSON value from a lazy <a>ByteString</a>. If
--   this fails due to incomplete or invalid input, <a>Nothing</a> is
--   returned.
--   
--   The input must consist solely of a JSON document, with no trailing
--   data except for whitespace.
--   
--   This function parses and performs conversion immediately. See
--   <a>json'</a> for details.
decodeStrict' :: (FromJSON a) => ByteString -> Maybe a

-- | Like <a>decodeStrict</a> but returns an error message when decoding
--   fails.
eitherDecodeStrict :: (FromJSON a) => ByteString -> Either String a

-- | Like <a>decodeStrict'</a> but returns an error message when decoding
--   fails.
eitherDecodeStrict' :: (FromJSON a) => ByteString -> Either String a

-- | A JSON value represented as a Haskell value.
data Value
Object :: !Object -> Value
Array :: !Array -> Value
String :: !Text -> Value
Number :: !Scientific -> Value
Bool :: !Bool -> Value
Null :: Value

-- | An encoding of a JSON value.
data Encoding

-- | Acquire the underlying bytestring builder.
fromEncoding :: Encoding -> Builder

-- | A JSON "array" (sequence).
type Array = Vector Value

-- | A JSON "object" (key/value map).
type Object = HashMap Text Value

-- | A newtype wrapper for <a>UTCTime</a> that uses the same non-standard
--   serialization format as Microsoft .NET, whose <a>System.DateTime</a>
--   type is by default serialized to JSON as in the following example:
--   
--   <pre>
--   /Date(1302547608878)/
--   </pre>
--   
--   The number represents milliseconds since the Unix epoch.
newtype DotNetTime
DotNetTime :: UTCTime -> DotNetTime

-- | Acquire the underlying value.
[fromDotNetTime] :: DotNetTime -> UTCTime

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   In many cases, you can get the compiler to generate parsing code for
--   you (see below). To begin, let's cover writing an instance by hand.
--   
--   There are various reasons a conversion could fail. For example, an
--   <a>Object</a> could be missing a required key, an <a>Array</a> could
--   be of the wrong size, or a value could be of an incompatible type.
--   
--   The basic ways to signal a failed conversion are as follows:
--   
--   <ul>
--   <li><tt>empty</tt> and <tt>mzero</tt> work, but are terse and
--   uninformative</li>
--   <li><a>fail</a> yields a custom error message</li>
--   <li><a>typeMismatch</a> produces an informative message for cases when
--   the value encountered is not of the expected type</li>
--   </ul>
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--     parseJSON (<a>Object</a> v) = Coord    <a>&lt;$&gt;</a>
--                            v <tt>.:</tt> "x" <a>&lt;*&gt;</a>
--                            v <tt>.:</tt> "y"
--   
--     -- We do not expect a non-<a>Object</a> value here.
--     -- We could use <tt>mzero</tt> to fail, but <a>typeMismatch</a>
--     -- gives a much more informative error message.
--     parseJSON invalid    = <a>typeMismatch</a> "Coord" invalid
--   </pre>
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   two options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>parseJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>FromJSON</a> instance for
--   your datatype without giving a definition for <a>parseJSON</a>.
--   
--   For example, the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance FromJSON Coord
--   </pre>
--   
--   If <tt>DefaultSignatures</tt> doesn't give exactly the results you
--   want, you can customize the generic decoding with only a tiny amount
--   of effort, using <a>genericParseJSON</a> with your preferred
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a where parseJSON = genericParseJSON defaultOptions
parseJSON :: FromJSON a => Value -> Parser a
parseJSON :: (FromJSON a, Generic a, GFromJSON (Rep a)) => Value -> Parser a

-- | The result of running a <a>Parser</a>.
data Result a
Error :: String -> Result a
Success :: a -> Result a

-- | Convert a value from JSON, failing if the types do not match.
fromJSON :: (FromJSON a) => Value -> Result a

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where
--     toJSON (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   
--     toEncoding (Coord x y) = <tt>pairs</tt> ("x" <a>.=</a> x <tt>&lt;&gt;</tt> "y" <a>.=</a> y)
--   </pre>
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are two
--   options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>toJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>ToJSON</a> instance for your
--   datatype without giving definitions for <a>toJSON</a> or
--   <a>toEncoding</a>.
--   
--   For example, the previous example can be simplified to a more minimal
--   instance:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance ToJSON Coord where
--       toEncoding = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
--   
--   Why do we provide an implementation for <a>toEncoding</a> here? The
--   <a>toEncoding</a> function is a relatively new addition to this class.
--   To allow users of older versions of this library to upgrade without
--   having to edit all of their instances or encounter surprising
--   incompatibilities, the default implementation of <a>toEncoding</a>
--   uses <a>toJSON</a>. This produces correct results, but since it
--   performs an intermediate conversion to a <a>Value</a>, it will be less
--   efficient than directly emitting an <a>Encoding</a>. Our one-liner
--   definition of <a>toEncoding</a> above bypasses the intermediate
--   <a>Value</a>.
--   
--   If <tt>DefaultSignatures</tt> doesn't give exactly the results you
--   want, you can customize the generic encoding with only a tiny amount
--   of effort, using <a>genericToJSON</a> and <a>genericToEncoding</a>
--   with your preferred <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON     = <a>genericToJSON</a> <a>defaultOptions</a>
--       toEncoding = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a where toJSON = genericToJSON defaultOptions toEncoding = Encoding . encodeToBuilder . toJSON

-- | Convert a Haskell value to a JSON-friendly intermediate type.
toJSON :: ToJSON a => a -> Value

-- | Convert a Haskell value to a JSON-friendly intermediate type.
toJSON :: (ToJSON a, Generic a, GToJSON (Rep a)) => a -> Value

-- | Encode a Haskell value as JSON.
--   
--   The default implementation of this method creates an intermediate
--   <a>Value</a> using <a>toJSON</a>. This provides source-level
--   compatibility for people upgrading from older versions of this
--   library, but obviously offers no performance advantage.
--   
--   To benefit from direct encoding, you <i>must</i> provide an
--   implementation for this method. The easiest way to do so is by having
--   your types implement <a>Generic</a> using the <tt>DeriveGeneric</tt>
--   extension, and then have GHC generate a method body as follows.
--   
--   <pre>
--   instance ToJSON Coord where
--       toEncoding = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
toEncoding :: ToJSON a => a -> Encoding

-- | A key-value pair for encoding a JSON object.
class KeyValue kv
(.=) :: (KeyValue kv, ToJSON v) => Text -> v -> kv

-- | Class of generic representation types (<a>Rep</a>) that can be
--   converted from JSON.
class GFromJSON f

-- | This method (applied to <a>defaultOptions</a>) is used as the default
--   generic implementation of <a>parseJSON</a>.
gParseJSON :: GFromJSON f => Options -> Value -> Parser (f a)

-- | Class of generic representation types (<a>Rep</a>) that can be
--   converted to JSON.
class GToJSON f

-- | This method (applied to <a>defaultOptions</a>) is used as the default
--   generic implementation of <a>toJSON</a>.
gToJSON :: GToJSON f => Options -> f a -> Value

-- | Class of generic representation types (<a>Rep</a>) that can be
--   converted to a JSON <a>Encoding</a>.
class GToEncoding f

-- | This method (applied to <a>defaultOptions</a>) can be used as the
--   default generic implementation of <a>toEncoding</a>.
gToEncoding :: GToEncoding f => Options -> f a -> Encoding

-- | A configurable generic JSON creator. This function applied to
--   <a>defaultOptions</a> is used as the default for <a>toJSON</a> when
--   the type is an instance of <a>Generic</a>.
genericToJSON :: (Generic a, GToJSON (Rep a)) => Options -> a -> Value

-- | A configurable generic JSON encoder. This function applied to
--   <a>defaultOptions</a> is used as the default for <a>toEncoding</a>
--   when the type is an instance of <a>Generic</a>.
genericToEncoding :: (Generic a, GToEncoding (Rep a)) => Options -> a -> Encoding

-- | A configurable generic JSON decoder. This function applied to
--   <a>defaultOptions</a> is used as the default for <a>parseJSON</a> when
--   the type is an instance of <a>Generic</a>.
genericParseJSON :: (Generic a, GFromJSON (Rep a)) => Options -> Value -> Parser a

-- | Default encoding <a>Options</a>:
--   
--   <pre>
--   <a>Options</a>
--   { <a>fieldLabelModifier</a>      = id
--   , <a>constructorTagModifier</a>  = id
--   , <a>allNullaryToStringTag</a>   = True
--   , <a>omitNothingFields</a>       = False
--   , <a>sumEncoding</a>             = <a>defaultTaggedObject</a>
--   , <a>unwrapUnaryRecords</a>      = False
--   }
--   </pre>
defaultOptions :: Options

-- | <tt>withObject expected f value</tt> applies <tt>f</tt> to the
--   <a>Object</a> when <tt>value</tt> is an <tt>Object</tt> and fails
--   using <tt><a>typeMismatch</a> expected</tt> otherwise.
withObject :: String -> (Object -> Parser a) -> Value -> Parser a

-- | <tt>withText expected f value</tt> applies <tt>f</tt> to the
--   <a>Text</a> when <tt>value</tt> is a <tt>String</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withText :: String -> (Text -> Parser a) -> Value -> Parser a

-- | <tt>withArray expected f value</tt> applies <tt>f</tt> to the
--   <a>Array</a> when <tt>value</tt> is an <tt>Array</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withArray :: String -> (Array -> Parser a) -> Value -> Parser a

-- | <tt>withNumber expected f value</tt> applies <tt>f</tt> to the
--   <a>Number</a> when <tt>value</tt> is a <a>Number</a>. and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.

-- | <i>Deprecated: Use withScientific instead</i>
withNumber :: String -> (Number -> Parser a) -> Value -> Parser a

-- | <tt>withScientific expected f value</tt> applies <tt>f</tt> to the
--   <a>Scientific</a> number when <tt>value</tt> is a <a>Number</a>. and
--   fails using <tt><a>typeMismatch</a> expected</tt> otherwise.
withScientific :: String -> (Scientific -> Parser a) -> Value -> Parser a

-- | <tt>withBool expected f value</tt> applies <tt>f</tt> to the
--   <a>Bool</a> when <tt>value</tt> is a <tt>Bool</tt> and fails using
--   <tt><a>typeMismatch</a> expected</tt> otherwise.
withBool :: String -> (Bool -> Parser a) -> Value -> Parser a

-- | A series of values that, when encoded, should be separated by commas.
--   Since 0.11.0.0, the <tt>.=</tt> operator is overloaded to create
--   either <tt>(Text, Value)</tt> or <a>Series</a>. You can use Series
--   when encoding directly to a bytestring builder as in the following
--   example:
--   
--   <pre>
--   toEncoding (Person name age) = pairs ("name" .= name &lt;&gt; "age" .= age)
--   </pre>
data Series

-- | Encode a series of key/value pairs, separated by commas.
pairs :: Series -> Encoding

-- | Encode a <a>Foldable</a> as a JSON array.
foldable :: (Foldable t, ToJSON a) => t a -> Encoding

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <tt>empty</tt> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use <a>.:?</a> instead.
(.:) :: (FromJSON a) => Object -> Text -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present, or
--   <tt>empty</tt> if the value cannot be converted to the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use <a>.:</a> instead.
(.:?) :: (FromJSON a) => Object -> Text -> Parser (Maybe a)

-- | Like <a>.:?</a>, but the resulting parser will fail, if the key is
--   present but is <a>Null</a>.
(.:!) :: (FromJSON a) => Object -> Text -> Parser (Maybe a)

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use
--   <a>.:</a> instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value

-- | Parse a top-level JSON value.
--   
--   The conversion of a parsed value to a Haskell value is deferred until
--   the Haskell value is needed. This may improve performance if only a
--   subset of the results of conversions are needed, but at a cost in
--   thunk allocation.
--   
--   This function is an alias for <a>value</a>. In aeson 0.8 and earlier,
--   it parsed only object or array types, in conformance with the
--   now-obsolete RFC 4627.
json :: Parser Value

-- | Parse a top-level JSON value.
--   
--   This is a strict version of <a>json</a> which avoids building up
--   thunks during parsing; it performs all conversions immediately. Prefer
--   this version if most of the JSON data needs to be accessed.
--   
--   This function is an alias for <a>value'</a>. In aeson 0.8 and earlier,
--   it parsed only object or array types, in conformance with the
--   now-obsolete RFC 4627.
json' :: Parser Value


-- | Functions to mechanically derive <a>ToJSON</a> and <a>FromJSON</a>
--   instances. Note that you need to enable the <tt>TemplateHaskell</tt>
--   language extension in order to use this module.
--   
--   An example shows how instances are generated for arbitrary data types.
--   First we define a data type:
--   
--   <pre>
--   data D a = Nullary
--            | Unary Int
--            | Product String Char a
--            | Record { testOne   :: Double
--                     , testTwo   :: Bool
--                     , testThree :: D a
--                     } deriving Eq
--   </pre>
--   
--   Next we derive the necessary instances. Note that we make use of the
--   feature to change record field names. In this case we drop the first 4
--   characters of every field name. We also modify constructor names by
--   lower-casing them:
--   
--   <pre>
--   $(<a>deriveJSON</a> <a>defaultOptions</a>{<a>fieldLabelModifier</a> = <tt>drop</tt> 4, <a>constructorTagModifier</a> = map toLower} ''D)
--   </pre>
--   
--   Now we can use the newly created instances.
--   
--   <pre>
--   d :: D <a>Int</a>
--   d = Record { testOne = 3.14159
--              , testTwo = <a>True</a>
--              , testThree = Product "test" 'A' 123
--              }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromJSON (toJSON d) == Success d
--   &gt; True
--   </pre>
--   
--   This also works for data family instances, but instead of passing in
--   the data family name (with double quotes), we pass in a data family
--   instance constructor (with a single quote):
--   
--   <pre>
--   data family DF a
--   data instance DF Int = DF1 Int
--                        | DF2 Int Int
--                        deriving Eq
--   
--   $(<a>deriveJSON</a> <a>defaultOptions</a> 'DF1)
--   -- Alternatively, one could pass 'DF2 instead
--   </pre>
--   
--   Please note that you can derive instances for tuples using the
--   following syntax:
--   
--   <pre>
--   -- FromJSON and ToJSON instances for 4-tuples.
--   $(<a>deriveJSON</a> <a>defaultOptions</a> ''(,,,))
--   </pre>
module Data.Aeson.TH

-- | Options that specify how to encode/decode your datatype to/from JSON.
data Options
Options :: (String -> String) -> (String -> String) -> Bool -> Bool -> SumEncoding -> Bool -> Options

-- | Function applied to field labels. Handy for removing common record
--   prefixes for example.
[fieldLabelModifier] :: Options -> String -> String

-- | Function applied to constructor tags which could be handy for
--   lower-casing them for example.
[constructorTagModifier] :: Options -> String -> String

-- | If <a>True</a> the constructors of a datatype, with <i>all</i> nullary
--   constructors, will be encoded to just a string with the constructor
--   tag. If <a>False</a> the encoding will always follow the
--   <a>sumEncoding</a>.
[allNullaryToStringTag] :: Options -> Bool

-- | If <a>True</a> record fields with a <a>Nothing</a> value will be
--   omitted from the resulting object. If <a>False</a> the resulting
--   object will include those fields mapping to <tt>null</tt>.
[omitNothingFields] :: Options -> Bool

-- | Specifies how to encode constructors of a sum datatype.
[sumEncoding] :: Options -> SumEncoding

-- | Hide the field name when a record constructor has only one field, like
--   a newtype.
[unwrapUnaryRecords] :: Options -> Bool

-- | Specifies how to encode constructors of a sum datatype.
data SumEncoding

-- | A constructor will be encoded to an object with a field
--   <a>tagFieldName</a> which specifies the constructor tag (modified by
--   the <a>constructorTagModifier</a>). If the constructor is a record the
--   encoded record fields will be unpacked into this object. So make sure
--   that your record doesn't have a field with the same label as the
--   <a>tagFieldName</a>. Otherwise the tag gets overwritten by the encoded
--   value of that field! If the constructor is not a record the encoded
--   constructor contents will be stored under the <a>contentsFieldName</a>
--   field.
TaggedObject :: String -> String -> SumEncoding
[tagFieldName] :: SumEncoding -> String
[contentsFieldName] :: SumEncoding -> String

-- | A constructor will be encoded to an object with a single field named
--   after the constructor tag (modified by the
--   <a>constructorTagModifier</a>) which maps to the encoded contents of
--   the constructor.
ObjectWithSingleField :: SumEncoding

-- | A constructor will be encoded to a 2-element array where the first
--   element is the tag of the constructor (modified by the
--   <a>constructorTagModifier</a>) and the second element the encoded
--   contents of the constructor.
TwoElemArray :: SumEncoding

-- | Default encoding <a>Options</a>:
--   
--   <pre>
--   <a>Options</a>
--   { <a>fieldLabelModifier</a>      = id
--   , <a>constructorTagModifier</a>  = id
--   , <a>allNullaryToStringTag</a>   = True
--   , <a>omitNothingFields</a>       = False
--   , <a>sumEncoding</a>             = <a>defaultTaggedObject</a>
--   , <a>unwrapUnaryRecords</a>      = False
--   }
--   </pre>
defaultOptions :: Options

-- | Default <a>TaggedObject</a> <a>SumEncoding</a> options:
--   
--   <pre>
--   defaultTaggedObject = <a>TaggedObject</a>
--                         { <a>tagFieldName</a>      = "tag"
--                         , <a>contentsFieldName</a> = "contents"
--                         }
--   </pre>
defaultTaggedObject :: SumEncoding

-- | Generates both <a>ToJSON</a> and <a>FromJSON</a> instance declarations
--   for the given data type or data family instance constructor.
--   
--   This is a convienience function which is equivalent to calling both
--   <a>deriveToJSON</a> and <a>deriveFromJSON</a>.
deriveJSON :: Options -> Name -> Q [Dec]

-- | Generates a <a>ToJSON</a> instance declaration for the given data type
--   or data family instance constructor.
deriveToJSON :: Options -> Name -> Q [Dec]

-- | Generates a <a>FromJSON</a> instance declaration for the given data
--   type or data family instance constructor.
deriveFromJSON :: Options -> Name -> Q [Dec]

-- | Generates a lambda expression which encodes the given data type or
--   data family instance constructor as a <a>Value</a>.
mkToJSON :: Options -> Name -> Q Exp

-- | Generates a lambda expression which encodes the given data type or
--   data family instance constructor as a JSON string.
mkToEncoding :: Options -> Name -> Q Exp

-- | Generates a lambda expression which parses the JSON encoding of the
--   given data type or data family instance constructor.
mkParseJSON :: Options -> Name -> Q Exp
instance Data.Aeson.Types.Class.FromJSON a => Data.Aeson.TH.LookupField a
instance Data.Aeson.Types.Class.FromJSON a => Data.Aeson.TH.LookupField (GHC.Base.Maybe a)
